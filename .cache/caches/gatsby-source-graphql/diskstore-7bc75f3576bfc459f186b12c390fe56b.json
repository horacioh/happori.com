{"expireTime":9007200856574030000,"key":"gatsby-source-graphql-schema-Product-products","val":"\"\"\"This directive allows results to be deferred during execution\"\"\"\ndirective @defer on FIELD\n\n\"\"\"\nTells the service this field/object has access authorized by sigv4 signing.\n\"\"\"\ndirective @aws_iam on OBJECT | FIELD_DEFINITION\n\n\"\"\"\nTells the service this field/object has access authorized by an OIDC token.\n\"\"\"\ndirective @aws_oidc on OBJECT | FIELD_DEFINITION\n\n\"\"\"\nTells the service which subscriptions will be published to when this mutation is\ncalled. This directive is deprecated use @aws_susbscribe directive instead.\n\"\"\"\ndirective @aws_publish(\n  \"\"\"\n  List of subscriptions which will be published to when this mutation is called.\n  \"\"\"\n  subscriptions: [String]\n) on FIELD_DEFINITION\n\n\"\"\"Tells the service which mutation triggers this subscription.\"\"\"\ndirective @aws_subscribe(\n  \"\"\"\n  List of mutations which will trigger this subscription when they are called.\n  \"\"\"\n  mutations: [String]\n) on FIELD_DEFINITION\n\n\"\"\"Directs the schema to enforce authorization on a field\"\"\"\ndirective @aws_auth(\n  \"\"\"List of cognito user pool groups which have access on this field\"\"\"\n  cognito_groups: [String]\n) on FIELD_DEFINITION\n\n\"\"\"\nTells the service this field/object has access authorized by an API key.\n\"\"\"\ndirective @aws_api_key on OBJECT | FIELD_DEFINITION\n\n\"\"\"\nTells the service this field/object has access authorized by a Cognito User Pools token.\n\"\"\"\ndirective @aws_cognito_user_pools(\n  \"\"\"List of cognito user pool groups which have access on this field\"\"\"\n  cognito_groups: [String]\n) on OBJECT | FIELD_DEFINITION\n\n\"\"\"\nThe `AWSDateTime` scalar type provided by AWS AppSync, represents a valid\n***extended*** [ISO 8601 DateTime](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations)\nstring. In other words, this scalar type accepts datetime strings of the form\n`YYYY-MM-DDThh:mm:ss.SSSZ`.  The scalar can also accept \"negative years\" of the\nform `-YYYY` which correspond to years before `0000`. For example,\n\"**-2017-01-01T00:00Z**\" and \"**-9999-01-01T00:00Z**\" are both valid datetime\nstrings.  The field after the two digit seconds field is a nanoseconds field. It\ncan accept between 1 and 9 digits. So, for example,\n\"**1970-01-01T12:00:00.2Z**\", \"**1970-01-01T12:00:00.277Z**\" and\n\"**1970-01-01T12:00:00.123456789Z**\" are all valid datetime strings.  The\nseconds and nanoseconds fields are optional (the seconds field must be specified\nif the nanoseconds field is to be used).  The [time zone\noffset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators) is\ncompulsory for this scalar. The time zone offset must either be `Z`\n(representing the UTC time zone) or be in the format `Â±hh:mm:ss`. The seconds\nfield in the timezone offset will be considered valid even though it is not part\nof the ISO 8601 standard.\n\"\"\"\nscalar AWSDateTime\n\ninput CreateProductInput {\n  id: ID\n  name: String!\n  description: String!\n  priceId: String!\n  price: Float!\n  image: String\n  currentInventory: Int!\n}\n\ninput DeleteProductInput {\n  id: ID\n}\n\nenum ModelAttributeTypes {\n  binary\n  binarySet\n  bool\n  list\n  map\n  number\n  numberSet\n  string\n  stringSet\n  _null\n}\n\ninput ModelBooleanInput {\n  ne: Boolean\n  eq: Boolean\n  attributeExists: Boolean\n  attributeType: ModelAttributeTypes\n}\n\ninput ModelFloatInput {\n  ne: Float\n  eq: Float\n  le: Float\n  lt: Float\n  ge: Float\n  gt: Float\n  between: [Float]\n  attributeExists: Boolean\n  attributeType: ModelAttributeTypes\n}\n\ninput ModelIDInput {\n  ne: ID\n  eq: ID\n  le: ID\n  lt: ID\n  ge: ID\n  gt: ID\n  contains: ID\n  notContains: ID\n  between: [ID]\n  beginsWith: ID\n  attributeExists: Boolean\n  attributeType: ModelAttributeTypes\n  size: ModelSizeInput\n}\n\ninput ModelIntInput {\n  ne: Int\n  eq: Int\n  le: Int\n  lt: Int\n  ge: Int\n  gt: Int\n  between: [Int]\n  attributeExists: Boolean\n  attributeType: ModelAttributeTypes\n}\n\ninput ModelProductConditionInput {\n  name: ModelStringInput\n  description: ModelStringInput\n  priceId: ModelStringInput\n  price: ModelFloatInput\n  image: ModelStringInput\n  currentInventory: ModelIntInput\n  and: [ModelProductConditionInput]\n  or: [ModelProductConditionInput]\n  not: ModelProductConditionInput\n}\n\ntype ModelProductConnection {\n  items: [Product]\n  nextToken: String\n}\n\ninput ModelProductFilterInput {\n  id: ModelIDInput\n  name: ModelStringInput\n  description: ModelStringInput\n  priceId: ModelStringInput\n  price: ModelFloatInput\n  image: ModelStringInput\n  currentInventory: ModelIntInput\n  and: [ModelProductFilterInput]\n  or: [ModelProductFilterInput]\n  not: ModelProductFilterInput\n}\n\ninput ModelSizeInput {\n  ne: Int\n  eq: Int\n  le: Int\n  lt: Int\n  ge: Int\n  gt: Int\n  between: [Int]\n}\n\nenum ModelSortDirection {\n  ASC\n  DESC\n}\n\ninput ModelStringInput {\n  ne: String\n  eq: String\n  le: String\n  lt: String\n  ge: String\n  gt: String\n  contains: String\n  notContains: String\n  between: [String]\n  beginsWith: String\n  attributeExists: Boolean\n  attributeType: ModelAttributeTypes\n  size: ModelSizeInput\n}\n\ntype Mutation {\n  createProduct(input: CreateProductInput!, condition: ModelProductConditionInput): Product\n  updateProduct(input: UpdateProductInput!, condition: ModelProductConditionInput): Product\n  deleteProduct(input: DeleteProductInput!, condition: ModelProductConditionInput): Product\n}\n\ntype Product {\n  id: ID!\n  name: String!\n  description: String!\n  priceId: String!\n  price: Float!\n  image: String\n  currentInventory: Int!\n  createdAt: AWSDateTime!\n  updatedAt: AWSDateTime!\n}\n\ntype Query {\n  getProduct(id: ID!): Product\n  listProducts(filter: ModelProductFilterInput, limit: Int, nextToken: String): ModelProductConnection\n}\n\ntype Subscription {\n  onCreateProduct: Product\n  onUpdateProduct: Product\n  onDeleteProduct: Product\n}\n\ninput UpdateProductInput {\n  id: ID!\n  name: String\n  description: String\n  priceId: String\n  price: Float\n  image: String\n  currentInventory: Int\n}\n"}